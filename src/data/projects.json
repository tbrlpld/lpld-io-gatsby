[
  {
    "name": "Wagtail Gatsby Blog (Frontend)",
    "description": "Frontend for a prototype Wagtail-Gatsby blog",
    "extendedDescription": "I created this project to figure out how I can use Wagtail as a headless CMS for a static website build with Gatsby. The backend makes use of Wagtail-Grapple to create the GraphQL endpoint. The GraphQL endpoint is consumed on the frontend with the help of the gatsby-source-wagtail plugin.<br /><br />Design and content are certainly not great, as I was focused on the technical implementation.",
    "image": "wagtail-gatsby-blog-frontend.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/wagtail-gatsby-blog-frontend",
    "live": "",
    "technologies": "Gatsby, Gatsby-Source-Wagtail, GraphQL, Headless-CMS, JavaScript, React, Wagtail, Wagtail-Grapple"
  },
  {
    "name": "Wagtail Gatsby Blog (Backend)",
    "description": "Backend for a prototype Wagtail-Gatsby blog",
    "extendedDescription": "I created this project to figure out how I can use Wagtail as a headless CMS for a static website build with Gatsby. The backend makes use of Wagtail-Grapple to create the GraphQL endpoint. The GraphQL endpoint is consumed on the frontend with the help of the gatsby-source-wagtail plugin.<br /><br />Design and content are certainly not great, as I was focused on the technical implementation.",
    "image": "wagtail-gatsby-blog-backend.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/wagtail-gatsby-blog-backend",
    "live": "",
    "technologies": "Django, Docker, Gatsby, GraphQL, Graphene, Graphene-Django, Headless-CMS, Poetry, Python, Vagrant, Wagtail, Wagtail-Grapple"
  },
  {
    "name": "Logtweet",
    "description": "Command line tool to create a tweet based on a #100DaysOfCode log message",
    "extendedDescription": "This is the first package I have published on PyPI. I have used this tool to tweet my daily progress during the #100DaysOfCode challenge.<br /><br />Tweets are generated based on an HTML log of a given format. I used <a href='/log100days-(gatsby)'>another project of mine (Log100Days)</a> to generate the HTML site from my Markdown journaling repo. The fact that the tool currently requires the log to be published as HTML is certainly not ideal. Since that HTML is generated from a Markdown log anyways, it would be a great addition to directly generate the tweet from the Markdown log. Unfortunately I have not gotten around to that feature yet.",
    "image": "logtweet.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/logtweet",
    "live": "https://pypi.org/project/logtweet/",
    "technologies": "Python, BeautifulSoup, web-scraping, Pytest, Twitter-API, mypy, "
  },
  {
    "name": "Log100Days (Gatsby)",
    "description": "Gatsby project to render a #100DaysOfCode markdown log into a static website",
    "extendedDescription": "I used this app to display <a href='https://github.com/tbrlpld/100-days-of-code' target='_blank'>my Markdown log</a>, that I used to document progress during the #100DaysOfCode challenge, as a website. This is the static version of a <a href='/log100days-(quart)'>dynamic Flask/Quart app</a> I had created as a learning exercise during the challenge. I switched to this static version, because it fits the static nature (updated once a day) of the content better and should be much more efficient for this purpose. I also wanted to practice Gatsby.<br/><br/>This project is a little different from the typical Gatsby project that generates HTML from Markdown files in that the Markdown files live in their own separate repository. To still have the site rebuild automatically when the content is updated, I added <a href='https://github.com/tbrlpld/100-days-of-code/blob/master/.github/workflows/update-netlify.yml'>a simple GitHub action</a> to the content repository that triggers the Netlify build hook.",
    "image": "log100days-gatsby.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/log100days-gatsby",
    "live": "https://log100days.lpld.io",
    "technologies": " JavaScript, React, JSX, Gatsby, CSS Modules, GitHub Actions, Netlify"
  },
  {
    "name": "Log100Days (Quart)",
    "description": "Containerized Quart app to display a markdown log for the #100DaysOfCode challenge as a website",
    "extendedDescription": "This app was initially build as a Flask learning exercise  and later on turned into a Quart app. Because Quart uses basically the same API as Flask, the changes where minimal but allowed the app to enjoy the asynchronous performance benefits.<br/><br/>The performance improvement through async are especially valuable in this app, because it pulled in external data (Markdown) and converted it into HTML on every request. Of course, that is still not a great process for an app that displays content that is only updated once per day. Because of that, I have also created <a href='/log100days-(gatsby)'>Log100Days (Gatsby)</a>, which generates a static site upon every update in the Markdown repository (which is way more efficient than even the async version of the dynamic app).",
    "image": "log100days-quart.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/log100days",
    "live": "",
    "technologies": "Python, Flask, Quart, Asyncio, Docker"
  },
  {
    "name": "Short",
    "description": "URL shortener app, build with Flask and AWS Dynamo DB and deployed with Zappa to AWS Lambda",
    "extendedDescription": "During the #100DaysOfCode challenge I was not only keeping a <a href='https://log100days.lpld.io' target='_blank'>log of my progress</a>, but also <a href='https://twitter.com/tbrlpld' target='_blank'>tweeting</a> about it. In those tweets I also typically included a link to the commit showing the code I had created that day. Because of the size length limitation of tweets, I did not want to waste characters on the link (which is typically pretty long when linking to a specific commit on GitHub) and therefore used URL shortener services like Bit.ly or TinyURL.<br/><br/>When I was trying to come up with a new project idea, I thought I could just replace the use of these external services and create my own URL shortener. And so I did. Short is certainly not as feature rich as some of the shortener services out there (e.g. no analytics) but it provides the basic functionality that I was looking for. I also included a public API endpoint that allowed me to make use of Short in <a href='/logtweet'>my command line tool (Logtweet)</a> to generate tweets based on my #100DaysOfCode log.",
    "image": "short.gif",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/short",
    "live": "https://s.lpld.io",
    "technologies": "Python, Flask, Zappa, AWS DynamoDB, AWS Lamba"
  },
  {
    "name": "Flaskr",
    "description": "Flask based blog app build as an extended version of the Flask tutorial",
    "extendedDescription": "Flaskr is the typical app that you create when going through the <a href='https://flask.palletsprojects.com/en/1.1.x/tutorial/' target='_blank'>Flask tutorial</a>. In the end of the tutorial you have a working blog application with user authentication and CRUD features for the blog posts.<br/><br/>The interesting part of the tutorial really starts on <a href='https://flask.palletsprojects.com/en/1.1.x/tutorial/next/' target='_blank'>the last page</a>, where it is suggested to continue the development by adding features like: detail post view, likes, comments, tags, title search, pagination, image upload, markdown formatting and RSS feed. I did implement each of these features and found it be a really tremendous learning experience. The experience not only thought me Flask, but Python and web development in general. The UI of the resulting blog app is definitely not pretty, but that was not the point of the exercise.",
    "image": "flaskr.png",
    "imageIsMacWindowScreenshot": true,
    "github": "https://github.com/tbrlpld/flaskr",
    "live": "",
    "technologies": "Python, Flask, Jinja, Test Driven Development, Pytest, Coverage"
  },
  {
    "name": "CAE Job Diary",
    "description": "Web application to search, track and summarize CAE simulation jobs",
    "extendedDescription": "I developed CAE Job Dairy as a side project to help me stay organized in my former day job as a <a href='https://en.wikipedia.org/wiki/Crash_simulation' target='_blank'>CAE simulation</a> and development engineer for automotive safety.<br/><br/>Simulation jobs added to the solver server cluster are polled and the submission information is automatically added to the web app. Changes to the jobs status are automatically update in the web app and you can leave a result summary after you analyzed your job. The web interface allows you to add summary notes and categorize the outcome of the simulation. You can also use the web app to search and filter jobs (by project and/or user).<br/><br/>CAE Job Dairy is probably the most complex app I have developed thus far (2020). Not because of the web app frontend. The frontend is extremely simple and does not even have user authentication (it was a feature idea but not necessary for the tiny user base at first). The complexities come in because of the different data files it has to parse, the events and conditions and connected race conditions on the file system it has to deal with. It was also my first larger app and I have learned a great deal about how to structure software since then. I probably would not build it like this again. Especially the coupling between the backend parsing processes and the Django web app have shown some significant down sides.",
    "image": "caejd.png",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/caejobdiary",
    "live": "",
    "technologies": "Python, Django, GitLab CI, Docker, MySQL, Bootstrap"
  },
  {
    "name": "PlotGraph",
    "description": "Sublime Text package to plot number columns as graphs",
    "extendedDescription": "",
    "image": "plotgraph.png",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/PlotGraph",
    "live": "",
    "technologies": "Python, Matplotlib, Sublime Text"
  },
  {
    "name": "100 Days Of Web in Python",
    "description": "45 (mini) projects I created from the \"100 Days Of Web in Python\" course during the 100DaysOfCode challenge",
    "extendedDescription": "Most projects where create in a few hours. I have extracted the projects I have worked on more into their own repositories.",
    "image": "100days-screencast.gif",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/100daysofweb-with-python-course",
    "live": "",
    "technologies": "API, API-Star, Alembic, Asyncio, CSS, DOM, Django, Django-Rest-framework, Docker, Flask, HTML, Heroku, JavaScript, Markdown, Nginx, Pelican, Pyramid, Python, Quart, REST, React, Requests, Responder, SQLAlchemy, Selenium, Static-Site-Generator, Twilio, Vuejs, mypy"
  },
  {
    "name": "Tic-Tac-Toe",
    "description": "Tic-Tac-Toe game created in React",
    "extendedDescription": "",
    "image": "tictactoe.gif",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/tictactoe",
    "live": "https://tictactoe.lpld.io",
    "technologies": "JSX, JavaScript, React"
  },
  {
    "name": "Remember Me",
    "description": "Web browser memory game (created for the Udacity Nanodegree \"Intro to Programming\")",
    "extendedDescription": "",
    "image": "rememberme.png",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/remember-me",
    "live": "https://rememberme.lpld.io",
    "technologies": "CSS, HTML, JavaScript, jQuery"
  },
  {
    "name": "Fill in the Gaps",
    "description": "Command line fill-in-the-gaps quiz game (created for the Udacity Nanodegree \"Intro to Programming\")",
    "extendedDescription": "",
    "image": "fill-in-the-gaps.gif",
    "imageIsMacWindowScreenshot": false,
    "github": "https://github.com/tbrlpld/fill-in-the-gaps",
    "live": "",
    "technologies": "Python"
  },
  {
    "name": "Tribute Page",
    "description": "Simple responsive tribute webpage for John Horton Conway (created for the freeCodeCamp Responsive Web Design certificate)",
    "extendedDescription": "",
    "image": "fcc-tribute-page.jpg",
    "imageIsMacWindowScreenshot": false,
    "github": "",
    "live": "https://codepen.io/tbrlpld/full/LYpbeRg",
    "technologies": "CSS, HTML"
  },
  {
    "name": "Technical Documentation",
    "description": "Simple responsive technical documentation page for Logtweet (created for the freeCodeCamp Responsive Web Design certificate)",
    "extendedDescription": "",
    "image": "fcc-technical-documentation.png",
    "imageIsMacWindowScreenshot": false,
    "github": "",
    "live": "https://codepen.io/tbrlpld/full/rNOpZgo",
    "technologies": ""
  },
  {
    "name": "Product Landing Page",
    "description": "Simple responsive product landing page for my favorite beers (created for the freeCodeCamp Responsive Web Design certificate)",
    "extendedDescription": "",
    "image": "fcc-product-landing-page.png",
    "imageIsMacWindowScreenshot": false,
    "github": "",
    "live": "https://codepen.io/tbrlpld/full/ExVXrQo",
    "technologies": "CSS, HTML"
  },
  {
    "name": "Survey Form",
    "description": "Simple responsive survey form (created for the freeCodeCamp Responsive Web Design certificate)",
    "extendedDescription": "",
    "image": "fcc-survey-form.png",
    "imageIsMacWindowScreenshot": false,
    "github": "",
    "live": "https://codepen.io/tbrlpld/full/KKdaEzb",
    "technologies": "CSS, HTML"
  }
]